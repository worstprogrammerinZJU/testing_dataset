# .github/workflows/test-arm64-smart.yml
name: Test ARM64 Assembly (Smart Input)

on: [push, workflow_dispatch]

jobs:
  test-arm64-smart:
    runs-on: macos-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Install tools
      run: |
        brew install coreutils
        which gtimeout
    
    - name: Smart test with auto input
      run: |
        echo "=== ARM64 汇编智能测试 ==="
        
        TOTAL=0
        COMPILE_OK=0
        EXECUTE_OK=0
        
        for file in *.s; do
          if [ -f "$file" ]; then
            TOTAL=$((TOTAL + 1))
            NAME="${file%.s}"
            
            echo ""
            echo "测试: $NAME"
            echo "=" * 40
            
            # 1. 编译
            echo "编译..."
            if clang "$file" -o "$NAME" 2>/tmp/compile_err; then
              COMPILE_OK=$((COMPILE_OK + 1))
              echo "✅ 编译成功"
              
              # 2. 分析程序需求，生成智能输入
              echo "分析程序需求..."
              
              # 检查汇编代码中的 scanf 格式字符串
              SCANF_PATTERNS=$(grep -o 'l_\.[a-zA-Z0-9_]*:' "$file" | grep -v 'main' | xargs -I {} grep -A1 "{}:" "$file" | grep -o '\".*\"' || true)
              
              echo "找到格式字符串: $SCANF_PATTERNS"
              
              # 生成测试输入
              INPUT_DATA=""
              
              if echo "$SCANF_PATTERNS" | grep -q '%d'; then
                # 有 %d 格式，需要整数输入
                echo "检测到 %d 格式，生成整数输入..."
                
                # 为第一个 scanf 生成测试数据
                if echo "$SCANF_PATTERNS" | grep -q '%d%d'; then
                  # 需要两个整数
                  INPUT_DATA="1\n10 20\n"
                elif echo "$SCANF_PATTERNS" | grep -q '%d'; then
                  # 需要一个整数
                  INPUT_DATA="1\n"
                fi
              fi
              
              # 如果没有检测到格式，使用通用输入
              if [ -z "$INPUT_DATA" ]; then
                INPUT_DATA="1\n2 3\n4 5\n6 7\n8 9\n10 11\n"
                echo "使用通用输入"
              else
                echo "使用生成输入: $INPUT_DATA"
              fi
              
              # 3. 执行测试
              echo "执行测试..."
              echo -e "$INPUT_DATA" | gtimeout 5 ./"$NAME" >/tmp/output 2>/tmp/error
              EXIT_CODE=$?
              
              if [ $EXIT_CODE -eq 0 ] || [ $EXIT_CODE -eq 124 ]; then
                # 0=成功, 124=timeout但可能成功
                EXECUTE_OK=$((EXECUTE_OK + 1))
                echo "✅ 执行成功 (退出码: $EXIT_CODE)"
                
                # 显示输出
                if [ -s /tmp/output ]; then
                  echo "程序输出:"
                  head -20 /tmp/output
                fi
              else
                echo "❌ 执行失败 (退出码: $EXIT_CODE)"
                
                if [ -s /tmp/error ]; then
                  echo "错误信息:"
                  head -20 /tmp/error
                fi
              fi
              
            else
              echo "❌ 编译失败"
              cat /tmp/compile_err
            fi
          fi
        done
        
        echo ""
        echo "=" * 40
        echo "测试完成"
        echo "=" * 40
        echo "总文件数: $TOTAL"
        echo "编译成功: $COMPILE_OK"
        echo "执行成功: $EXECUTE_OK"
        
        if [ $TOTAL -gt 0 ]; then
          COMPILE_RATE=$((COMPILE_OK * 100 / TOTAL))
          echo "编译成功率: $COMPILE_RATE%"
          
          if [ $COMPILE_OK -gt 0 ]; then
            EXECUTE_RATE=$((EXECUTE_OK * 100 / COMPILE_OK))
            echo "执行成功率: $EXECUTE_RATE%"
          fi
        fi
