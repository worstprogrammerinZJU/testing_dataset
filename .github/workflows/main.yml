# .github/workflows/test-macos-arm64.yml
name: Test macOS ARM64 Assembly

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-macos-arm64:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup environment
      run: |
        echo "=== 环境信息 ==="
        uname -a
        clang --version
        echo "当前目录:"
        pwd
        ls -la *.s 2>/dev/null | wc -l
    
    - name: Compile and test ARM64 assembly
      id: test
      run: |
        echo "=== 编译和测试 macOS ARM64 汇编 ==="
        
        COMPILE_SUCCESS=0
        COMPILE_TOTAL=0
        EXECUTE_SUCCESS=0
        
        # 创建测试输入
        echo "创建测试输入文件..."
        echo "3" > test_input.txt
        echo "10 5" >> test_input.txt
        echo "20 8" >> test_input.txt
        echo "15 6" >> test_input.txt
        
        # 查找所有 .s 文件
        ASM_FILES=$(find . -name "*.s" -type f | sort)
        echo "找到的汇编文件:"
        echo "$ASM_FILES"
        echo ""
        
        for asm_file in $ASM_FILES; do
          if [ -f "$asm_file" ]; then
            COMPILE_TOTAL=$((COMPILE_TOTAL + 1))
            filename=$(basename "$asm_file" .s)
            
            echo "测试: $filename"
            
            # 1. 编译
            echo "编译: $asm_file"
            if clang "$asm_file" -o "$filename" 2>"${filename}_compile.log"; then
              echo "✅ 编译成功"
              COMPILE_SUCCESS=$((COMPILE_SUCCESS + 1))
              
              # 2. 执行（不使用 timeout）
              echo "执行: $filename"
              
              # 方法1: 使用 gtimeout（macOS 需要 coreutils）
              if command -v gtimeout >/dev/null 2>&1; then
                # 有 gtimeout
                if echo -e "1\n10 5\n20 8\n15 6" | gtimeout 5 ./"$filename" >"${filename}_output.log" 2>"${filename}_error.log"; then
                  EXIT_CODE=$?
                  echo "✅ 执行成功 (退出码: $EXIT_CODE)"
                  EXECUTE_SUCCESS=$((EXECUTE_SUCCESS + 1))
                else
                  EXIT_CODE=$?
                  echo "❌ 执行失败 (退出码: $EXIT_CODE)"
                fi
              else
                # 没有 timeout，直接执行
                if echo -e "1\n10 5\n20 8\n15 6" | ./"$filename" >"${filename}_output.log" 2>"${filename}_error.log"; then
                  EXIT_CODE=$?
                  echo "✅ 执行成功 (退出码: $EXIT_CODE)"
                  EXECUTE_SUCCESS=$((EXECUTE_SUCCESS + 1))
                else
                  EXIT_CODE=$?
                  echo "❌ 执行失败 (退出码: $EXIT_CODE)"
                fi
              fi
              
              # 显示输出
              if [ -s "${filename}_output.log" ]; then
                echo "输出:"
                head -20 "${filename}_output.log"
              fi
              
              if [ -s "${filename}_error.log" ]; then
                echo "错误:"
                head -20 "${filename}_error.log"
              fi
            else
              echo "❌ 编译失败"
              if [ -s "${filename}_compile.log" ]; then
                echo "编译错误:"
                head -20 "${filename}_compile.log"
              fi
            fi
            echo ""
          fi
        done
        
        # 计算成功率
        if [ $COMPILE_TOTAL -gt 0 ]; then
          COMPILE_RATE=$((COMPILE_SUCCESS * 100 / COMPILE_TOTAL))
        else
          COMPILE_RATE=0
        fi
        
        if [ $COMPILE_SUCCESS -gt 0 ]; then
          EXECUTE_RATE=$((EXECUTE_SUCCESS * 100 / COMPILE_SUCCESS))
        else
          EXECUTE_RATE=0
        fi
        
        echo "=== 最终结果 ==="
        echo "编译成功率: $COMPILE_SUCCESS/$COMPILE_TOTAL ($COMPILE_RATE%)"
        echo "执行成功率: $EXECUTE_SUCCESS/$COMPILE_SUCCESS ($EXECUTE_RATE%)"
        echo "端到端成功率: $EXECUTE_SUCCESS/$COMPILE_TOTAL ($((EXECUTE_SUCCESS * 100 / COMPILE_TOTAL))%)"
        
        # 保存结果
        echo "compile_success=$COMPILE_SUCCESS" >> $GITHUB_OUTPUT
        echo "compile_total=$COMPILE_TOTAL" >> $GITHUB_OUTPUT
        echo "execute_success=$EXECUTE_SUCCESS" >> $GITHUB_OUTPUT
    
    - name: Clean up
      run: |
        # 清理编译的可执行文件
        rm -f a.out
        for file in *.s; do
          if [ -f "$file" ]; then
            filename="${file%.s}"
            rm -f "$filename" "${filename}_compile.log" "${filename}_output.log" "${filename}_error.log"
          fi
        done
        rm -f test_input.txt
